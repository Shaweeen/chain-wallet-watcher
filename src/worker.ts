export interface Env {\n  ETH_WALLET?: string;\n  ETH_RPC?: string;\n  BSC_WALLET?: string;\n  BSC_RPC?: string;\n  POLYGON_WALLET?: string;\n  POLYGON_RPC?: string;\n  SOL_WALLET?: string;\n  SOL_RPC?: string;\n  BTC_WALLET?: string;\n  TELEGRAM_BOT_TOKEN: string;\n  TELEGRAM_CHAT_ID: string;\n}\n\nconst TOKEN_CONFIG = {\n  ETH: {\n    symbol: 'ETH',\n    tokens: [\n      { symbol: 'USDC', address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', decimals: 6 },\n      { symbol: 'USDT', address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', decimals: 6 },\n    ]\n  },\n  BSC: {\n    symbol: 'BNB',\n    tokens: [\n      { symbol: 'USDC', address: '0x8AC76a51cc950d9822D68b83fE1Ad97B44470c99', decimals: 18 },\n      { symbol: 'USDT', address: '0x55d398326f99059fF775485246999027B3197955', decimals: 18 },\n    ]\n  },\n  POLYGON: {\n    symbol: 'MATIC',\n    tokens: [\n      { symbol: 'USDC', address: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', decimals: 6 },\n      { symbol: 'USDT', address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', decimals: 6 },\n    ]\n  },\n  SOL: {\n    symbol: 'SOL',\n    tokens: [\n      { symbol: 'USDC', address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', decimals: 6 },\n    ]\n  }\n};\n\nexport default {\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {\n    ctx.waitUntil(handleScheduled(env));\n  },\n\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    await handleScheduled(env);\n    return new Response(\"Multi-chain monitoring triggered\");\n  },\n};\n\nasync function handleScheduled(env: Env) {\n  const reports: string[] = [];\n\n  if (env.ETH_WALLET && env.ETH_RPC) {\n    reports.push(await checkEVM('Ethereum', env.ETH_RPC, env.ETH_WALLET, TOKEN_CONFIG.ETH));\n  }\n\n  if (env.BSC_WALLET && env.BSC_RPC) {\n    reports.push(await checkEVM('BSC', env.BSC_RPC, env.BSC_WALLET, TOKEN_CONFIG.BSC));\n  }\n\n  if (env.POLYGON_WALLET && env.POLYGON_RPC) {\n    reports.push(await checkEVM('Polygon', env.POLYGON_RPC, env.POLYGON_WALLET, TOKEN_CONFIG.POLYGON));\n  }\n\n  if (env.SOL_WALLET && env.SOL_RPC) {\n    reports.push(await checkSolana(env.SOL_RPC, env.SOL_WALLET, TOKEN_CONFIG.SOL));\n  }\n\n  if (env.BTC_WALLET) {\n    reports.push(await checkBitcoin(env.BTC_WALLET));\n  }\n\n  const finalReport = reports.filter(r => r).join('\\n\\n');\n  if (finalReport) {\n    await sendTelegramNotification(env.TELEGRAM_BOT_TOKEN, env.TELEGRAM_CHAT_ID, \"üöÄ **Multi-Chain Wallet Report**\\n\\n\" + finalReport);\n  }\n}\n\nasync function checkEVM(chainName: string, rpc: string, wallet: string, config: any) {\n  try {\n    const nativeBalance = await getEVMBalance(rpc, wallet);\n    const nativeValue = (BigInt(nativeBalance) / BigInt(1e14)).toString();\n    let report = \"üåê **\" + chainName + \"**\\nWallet: \" + wallet.slice(0, 6) + \"...\" + wallet.slice(-4) + \"\\n\" + config.symbol + \": \" + (Number(nativeValue) / 10000);\n\n    for (const token of config.tokens) {\n      const balance = await getERC20Balance(rpc, wallet, token.address);\n      const val = Number(BigInt(balance)) / Math.pow(10, token.decimals);\n      report += \"\\n\" + token.symbol + \": \" + val.toFixed(2);\n    }\n    return report;\n  } catch (e) {\n    return \"‚ùå \" + chainName + \" Error: \" + e.message;\n  }\n}\n\nasync function checkSolana(rpc: string, wallet: string, config: any) {\n  try {\n    const nativeRes = await fetch(rpc, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'getBalance', params: [wallet] })\n    });\n    const nativeData: any = await nativeRes.json();\n    const solBalance = nativeData.result.value / 1e9;\n    let report = \"‚òÄÔ∏è **Solana**\\nWallet: \" + wallet.slice(0, 6) + \"...\" + wallet.slice(-4) + \"\\nSOL: \" + solBalance.toFixed(4);\n\n    for (const token of config.tokens) {\n      const tokenRes = await fetch(rpc, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          id: 1,\n          method: 'getTokenAccountsByOwner',\n          params: [wallet, { mint: token.address }, { encoding: 'jsonParsed' }]\n        })\n      });\n      const tokenData: any = await tokenRes.json();\n      const accounts = tokenData.result.value;\n      const balance = accounts.length > 0 ? accounts[0].account.data.parsed.info.tokenAmount.uiAmount : 0;\n      report += \"\\n\" + token.symbol + \": \" + balance.toFixed(2);\n    }\n    return report;\n  } catch (e) {\n    return \"‚ùå Solana Error: \" + e.message;\n  }\n}\n\nasync function checkBitcoin(wallet: string) {\n  try {\n    const res = await fetch(\"https://blockchain.info/q/addressbalance/\" + wallet);\n    const satoshis = await res.text();\n    const btcBalance = Number(satoshis) / 1e8;\n    return \"‚Çø **Bitcoin**\\nWallet: \" + wallet.slice(0, 6) + \"...\" + wallet.slice(-4) + \"\\nBTC: \" + btcBalance.toFixed(8);\n  } catch (e) {\n    return \"‚ùå Bitcoin Error: \" + e.message;\n  }\n}\n\nasync function getEVMBalance(rpc: string, address: string): Promise<string> {\n  const res = await fetch(rpc, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ jsonrpc: '2.0', method: 'eth_getBalance', params: [address, 'latest'], id: 1 })\n  });\n  const data: any = await res.json();\n  return data.result || '0';\n}\n\nasync function getERC20Balance(rpc: string, wallet: string, tokenAddress: string): Promise<string> {\n  const data = '0x70a08231' + wallet.substring(2).padStart(64, '0');\n  const res = await fetch(rpc, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      jsonrpc: '2.0',\n      method: 'eth_call',\n      params: [{ to: tokenAddress, data: data }, 'latest'],\n      id: 1\n    })\n  });\n  const json: any = await res.json();\n  return json.result || '0';\n}\n\nasync function sendTelegramNotification(token: string, chatId: string, message: string) {\n  const url = \"https://api.telegram.org/bot\" + token + \"/sendMessage\";\n  await fetch(url, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ chat_id: chatId, text: message, parse_mode: 'Markdown' })\n  });\n}